# CS230

The Gaming Room wants to develop a web-based game that serves multiple platforms based on their current game, Draw It or Lose It, which is currently available in an Android app only. The main goal is to create a game that has multiple teams consisting of more than one person. A game consists of four rounds of play lasting one minute each. Drawings are rendered at a steady rate and are fully complete at the 30-second mark. If the team does not guess the puzzle before time expires, the remaining teams have an opportunity to offer one guess each to solve the puzzle with a 15-second time limit. 
Something that I did well in this project was my UML document and understanding the need of the document and why it is so important. 
Seeing exaclty what the client wanted helped me in being able to reccomend the best solution for the client. If I could choose one part of my document to revise it would be the Evaulation. Going into that week I still wasn't quite sure how it all worked and didn't really understand the assignment. Looking back I would change some things in that part of my document. It is incredibly important to consider the user's needs when designing because when you are designing a program without that consideration, your client's application will not be user friendly. At the end of the day, if it is not easy for the user, then they will not use it. I think that there is a balance between usability, and complexity as sometimes complexity is needed and not everything needs to be simple. Though when implementing an application for users to use, we need to focus on the scope of the application, and what does need to be easy so we can make the app enjoyable to use. I think that the most important part of designing software is incrementally designing each part within the architecture of the application. When incrementally designing, you are able to focus and fine tune each part with the most cohesive type of perception, because your mind will not be cluttered with unneccesary details making the application architecture worse in the long run. This way you can also seperate each of the functions, and program them one by one, to make the code itself the best it can be.

